# Spanner Q&A

### Q: spanner的 workload 跟processingunit 和split是什么关系

A:
简单来说，这三者的关系是：

*   你购买 **Processing Units (PUs)** 来获得计算能力。
*   Spanner 将你的数据自动切分成 **Splits**，并把这些 Splits 分配给不同的服务器去管理。
*   你的 **Workload** (读写请求) 由管理着相关 Splits 的服务器来处理。

**核心关键点**：只有当你的 Workload 均匀地分布在所有的 Splits 上时，你购买的 Processing Units 才能被充分利用。如果 Workload 集中在少数几个 Splits 上（即“热点”），那么大部分 PUs 就会处于空闲状态，从而导致性能瓶颈。

---

### 详细解释

1.  **Processing Units (PUs) / Nodes**
    *   **是什么**：这是你为 Spanner 实例购买的计算资源，包括 CPU、内存和网络带宽。你可以把它看作是 Spanner 实例的总马力。1000个PUs等于1个节点 (Node)。
    *   **作用**：提供处理你的读写请求（Workload）所需的所有计算能力。越多的 PUs 意味着越强的整体处理能力。

2.  **Splits (数据分片)**
    *   **是什么**：Spanner 是一个分布式数据库，它会自动将你的表数据按主键 (Primary Key) 的范围切分成很多个小块，每一块就是一个 "Split"。每个 Split 包含一段连续的行。
    *   **作用**：Spanner 通过 Splits 来实现数据的分布式存储和负载均衡。数据库会把不同的 Splits 移动到不同的服务器上，这样就可以并行处理落在不同 Splits 上的请求。Spanner 会根据数据量和访问压力自动地进行分裂（将一个 Split 拆成两个）或合并。

3.  **Workload (工作负载)**
    *   **是什么**：指你的应用程序对数据库发起的各种操作，主要是读（Read）和写（Write）请求。
    *   **作用**：这是对数据库性能的直接需求。Workload 的模式（例如，是大量读取少量数据，还是频繁更新单条记录）决定了数据库的压力来源。

### 三者如何协同工作

想象一个大型超市：

*   **Processing Units** 是你雇佣的收银员总数。
*   **Splits** 是开放的收银通道。
*   **Workload** 是排队结账的顾客。

1.  **理想情况 (负载均衡)**：超市的引导员（Spanner）将顾客（Workload）均匀地引导到所有开放的收银通道（Splits）。这样，你雇佣的所有收银员（PUs）都在忙碌，整个超市的结账效率最高。
2.  **糟糕情况 (热点 Hotspot)**：由于某种原因（例如，某个通道有明星在做活动），所有顾客（Workload）都涌向了同一个收银通道（单个 Split）。这时，即使你雇佣了很多收银员（PUs），也只有负责这个通道的那个收银员在拼命工作，其他人都在闲着。整个超市的效率取决于这一个不堪重负的通道，这就是性能瓶颈。

正如 `schema-design.md` 中提到的，避免使用连续递增的主键（如自增ID或时间戳）就是为了防止写入操作全部集中在表的“末尾”，从而造成写入热点，让 Workload 无法被有效分散到所有 Splits 上。选择 UUID 或经过 Hash 计算的唯一 ID 作为主键，可以使写入操作随机分布到整个键空间，从而让负载更加均衡。

**总结**：增加 Processing Units 可以提升整个实例的总性能上限，但要真正发挥这些性能，你必须通过良好的 schema 设计（尤其是主键设计）来确保你的 Workload 能够均匀地分散到足够多的 Splits 上。

---

### Q: Spanner的 Readonly Transaction 跟 Single-Use Transaction 分别使用在什么场景？

A:
简单来说，选择哪种事务类型取决于你需要执行的**读取操作次数**。

*   **Read-Only Transaction (只读事务)**: 当你需要在一个时间点上执行**多次读取**，并确保所有读取的数据保持一致性时使用。
*   **Single-Use Transaction (单次使用事务)**: 当你只需要执行**单次、独立的读取**操作时使用，它的开销更小。

---

### 详细解释

| 特性 | Read-Only Transaction | Single-Use Read |
| --- | --- | --- |
| **主要用途** | 需要在同一时间点进行多次、一致性的读取 | 执行单次、独立的读取操作 |
| **一致性** | 保证事务内的所有读取操作看到的是同一个数据快照 | 保证单次操作的强一致性（看到所有已提交的数据） |
| **锁** | 不会加锁，因此不会阻塞写入操作 | 不会加锁 |
| **写入** | 不允许 | 不允许 |
| **性能** | 为多次读取优化；使用旧时间戳（Stale Read）可以进一步提升性能 | 对于单次读取，性能开销更低 |

#### Read-Only Transaction 的使用场景

当你需要保证数据的一致性视图时，这是最佳选择。例如：
1.  **生成报表**: 一个报表可能需要从多个表中查询数据（如 `Users`, `Orders`, `Products`），使用只读事务可以确保所有查询结果都来自同一个时间点，避免数据在查询过程中发生变化而导致报表内容不一致。
2.  **复杂的业务逻辑**: 当一个业务功能需要先读取一些配置数据，再根据配置数据去读取其他业务数据时，为了保证整个操作的一致性，应将它们包裹在一个只读事务中。
3.  **数据导出与分析**: 在进行大规模数据导出或分析（如 MapReduce）时，需要一个稳定的数据视图。

#### Single-Use Transaction 的使用场景

当你的操作足够简单，只需要一次数据库交互时，这是更高效的选择。例如：
1.  **根据ID获取单个实体**: `SELECT * FROM Users WHERE UserId = @id`。
2.  **简单的列表查询**: 获取某个用户最近的10个订单。
3.  **API中的独立读取**: 在处理一个API请求时，如果只需要从数据库中读取一条记录来验证权限或获取信息，那么单次读取是最佳选择。

**总结**: 如果你的代码块中包含了多个 `db.Read()` 或 `db.Query()` 调用，并且它们的结果需要相互关联、保持一致，那么就应该使用 **Read-Only Transaction**。如果代码块中只有一个数据库读取操作，那么使用 **Single-Use Read** 会更直接、更高效。